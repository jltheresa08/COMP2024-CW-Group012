package sa;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class SimulatedAnnealingTSP {

    private static final double INITIAL_TEMPERATURE = 1000;
    private static final double FINAL_TEMPERATURE = 1;
    private static final double COOLING_FACTOR = 0.99;
    private static final int MAX_ITERATIONS = 1000;

    private static List<City> cities;
    private static int numCities;
    private static double[][] distances;

    public static void main(String[] args) {
        readInputFile("TSP_107.txt");
        initializeDistances();

        Tour currentTour = new Tour(cities);
        Tour bestTour = new Tour(currentTour);

        double temp = INITIAL_TEMPERATURE;

        for (int i = 0; i < MAX_ITERATIONS; i++) {
            Tour newTour = new Tour(currentTour);

            int city1 = (int) (Math.random() * numCities);
            int city2 = (int) (Math.random() * numCities);

            newTour.swapCities(city1, city2);

            double currentEnergy = currentTour.getTourDistance(distances);
            double newEnergy = newTour.getTourDistance(distances);

            if (acceptNewSolution(currentEnergy, newEnergy, temp)) {
                currentTour = new Tour(newTour);
            }

            if (currentTour.getTourDistance(distances) < bestTour.getTourDistance(distances)) {
                bestTour = new Tour(currentTour);
            }

            temp *= COOLING_FACTOR;

            if (temp < FINAL_TEMPERATURE) {
                break;
            }
        }

        System.out.println("Best tour cost: " + bestTour.getTourDistance(distances));
        System.out.println("Best tour order: " + bestTour.toString());
    }
    
    /**
     * Reads city data from a text file and create City objects to represent each city
     * 
     * @param filename the name of the file containing city data
     */

    private static void readInputFile(String filename) {
    	/**
    	 * An ArrayList to store the cities
    	 */
        cities = new ArrayList<>();
        try (Scanner scanner = new Scanner(new File(filename))) {
            while (scanner.hasNextLine()) {
            	
                String line = scanner.nextLine();
                String[] tokens = line.split(" ");
                
                if (line.equals("EOF")) {
                    break;
                }
                
                int id = Integer.parseInt(tokens[0]);
                int x = Integer.parseInt(tokens[1]);
                int y = Integer.parseInt(tokens[2]);
                City city = new City(id, x, y);
                cities.add(city);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        /**
         * The number of cities in the ArrayList
         */
        numCities = cities.size();
    }

    /**
     * Initialize a 2D array of distances between cities
     * The (i, j)-th element represents the distance between the i-th and j-th cities
     * Uses the distanceTo() method of the City class to calculate the distances
     */
    private static void initializeDistances() {
    	/**
    	 * A 2D array of distances between cities
    	 * The (i, j)-th element represents the distance between the i-th and j-th cities
    	 */
        distances = new double[numCities][numCities];
        for (int i = 0; i < numCities; i++) {
            City city1 = cities.get(i);
            for (int j = 0; j < numCities; j++) {
                City city2 = cities.get(j);
                double distance = city1.distanceTo(city2);
                distances[i][j] = distance;
            }
        }
    }

    /**
     * Determines whether or not to accept a new solution in a simulated annealing algorithm
     * Compares the new energy to the current energy and the temperature of the system
     * Uses an acceptance probability equation to make the decision
     * @param currentEnergy the current energy of the system
     * @param newEnergy the energy of the new solution
     * @param temperature the temperature of the system
     * @return true if the new solution should be accepted, false otherwise
     */
    private static boolean acceptNewSolution(double currentEnergy, double newEnergy, double temperature) {
        if (newEnergy < currentEnergy) {
            return true;
        }
        double acceptanceProbability = Math.exp((currentEnergy - newEnergy) / temperature);
        return Math.random() < acceptanceProbability;
    }
    
    /**
     * Represents a city in a traveling salesman problem, with an ID and x and y coordinates
     * Provides a method to calculate the distance between two cities
     */
    private static class City {
        private int id;
        private int x;
        private int y;
        
        /**
         * Construct a new City object with the specified ID and x and y coordinates
         * @param id the ID of the city
         * @param x the x coordinate of the city
         * @param y the y coordinate of the city
         */
        public City(int id, int x, int y) {
            this.id = id;
            this.x = x;
            this.y = y;
        }

        public int getId() {
            return id;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        /**
         * Calculate the distance between this city and another city
         * @param other the other city to calculate the distance to __
         * @return the distance between this city and the other city
         */
        public double distanceTo(City other) {
            int dx = x - other.getX();
            int dy = y - other.getY();
            return Math.sqrt(dx * dx + dy * dy);
        }
    }

    /**
     * 
     * Represents a tour of cities in a traveling salesman problem
     * Provide method to create new tours from existing ones, get the order of cities in the tour and display the tour as a string
     *
     */
    private static class Tour {
        private List<City> cities;

        /**
         * Constructs a new Tour object with the specified list of cities
         * @param cities the list of cities in the tour
         */
        public Tour(List<City> cities) {
            this.cities = new ArrayList<>(cities);
        }
        
        /**
         * Constructs a new Tour object with the same list of cities as the specifies Tour object
         * @param tour the Tour object to copy the list of cities
         */
        public Tour(Tour tour) {
        	this.cities = new ArrayList<>(tour.cities);
        }

        public String getCityOrder() {
            return cities.toString();
        }
        
        /**
         * Returns  a string representation of the tour
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            for (City city : cities) {
                sb.append(city.getId()).append(", ");
            }
            sb.delete(sb.length() - 2, sb.length()); // remove trailing comma and space
            sb.append("]");
            return sb.toString();
        }

        /**
         * Calculate the total distance of tour
         * @param distances a 2D array representing the distances between cities
         * @return total distamce of tour
         */
        public double getTourDistance(double[][] distances) {
            double distance = 0;
            for (int i = 0; i < numCities - 1; i++) {
                City city1 = cities.get(i);
                City city2 = cities.get(i + 1);
                distance += distances[city1.getId() - 1][city2.getId() - 1];
            }
            City lastCity = cities.get(numCities - 1);
            City firstCity = cities.get(0);
            distance += distances[lastCity.getId() - 1][firstCity.getId() - 1];
            return distance;
        }

        /**
         * Swap the positions of two cities in the tour
         * @param i the index of first city to be swapped
         * @param j the index of second city to be swapped
         */
        public void swapCities(int i, int j) {
            if (i != j) {
                City temp = cities.get(i);
                cities.set(i, cities.get(j));
                cities.set(j, temp);
            }
        }
    }
}
