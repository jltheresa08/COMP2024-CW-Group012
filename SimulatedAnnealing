package sa;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class SimulatedAnnealingTSP {
    private static final double INITIAL_TEMPERATURE = 10000;
    private static final double FINAL_TEMPERATURE = 0;
    private static final double COOLING_FACTOR = 0.9;
    private static final int MAX_ITERATIONS = 60000;

    private static List<City> cities;
    private static int numCities;
    private static double[][] distances;

    public static void main(String[] args) throws IOException {
    	BufferedWriter writer = new BufferedWriter(new FileWriter("compare.txt",true));
    	writer.write("Initial temp: "+ INITIAL_TEMPERATURE + "\n");
    	writer.write("Initial temp: "+ COOLING_FACTOR + "\n");
        writer.write("Iterations: "+ MAX_ITERATIONS + "\n"); //HERE TO CHANGE UR HEADING
        for(int b=0;b<30;b++)
        {
    	long startTime = System.currentTimeMillis();
        readInputFile("TSP_107.txt");
//        initializeDistances();

        Tour currentTour = new Tour(cities);
       
        
        int it = 5;
        for(int a=0;a<it;a++) {
        	int city1 = (int) (Math.random() * numCities);
            int city2 = (int) (Math.random() * numCities);
            currentTour.swapCities(city1, city2);
       }
        
        Tour bestTour = new Tour(currentTour);
        System.out.println(bestTour);
        
        
        
        double temp = INITIAL_TEMPERATURE;

        for (int i = 0; i < MAX_ITERATIONS; i++) {
            Tour newTour = new Tour(currentTour);
//            double currentEnergy = currentTour.getTourDistance(distances);
//            double newEnergy = newTour.getTourDistance(distances);
            it = 50000;
            for(int a=0;a<it;a++) {
            	int  city1 = (int) (Math.random() * numCities);
                int  city2 = (int) (Math.random() * numCities);
                newTour.swapCities(city1, city2);
            }
            System.out.println("new" + newTour);
            
            double currentEnergy = currentTour.getTourDistance();
            double newEnergy = newTour.getTourDistance();
            double bestenergy = bestTour.getTourDistance();
            System.out.println("hhhhhhhhhhhh" + bestenergy);
            
            
            if (temp > FINAL_TEMPERATURE) {
	            if (acceptNewSolution(currentEnergy, newEnergy, temp)) {
	                currentTour = new Tour(newTour);
	            }
	            bestTour = new Tour(currentTour);
	            
	            temp *= COOLING_FACTOR;
            }
            else
            {
            	currentTour = new Tour(newTour);
//            	System.out.println(currentTour.getTourDistance());
//            	System.out.println(bestTour.getTourDistance());
            	if (currentTour.getTourDistance() < bestTour.getTourDistance()) {
                    bestTour = new Tour(currentTour);
                    System.out.println("hi");
                }
            }

       
            
            
//            currentTour = new Tour(newTour);
//            
//            if (temp <= FINAL_TEMPERATURE) {
//            	if (currentTour.getTourDistance(distances) < bestTour.getTourDistance(distances)) {
//                    bestTour = new Tour(currentTour);
//                }
//                
//            }
//            else
//            {
//            	if (currentTour.getTourDistance(distances) < bestTour.getTourDistance(distances)) {
//            		bestTour = new Tour(currentTour);
//            	}
//            	else if (acceptNewSolution(currentEnergy, newEnergy, temp)) {
//                	bestTour = new Tour(currentTour);
//                }
//            	
//            	temp *= COOLING_FACTOR;
//            }
            	
            
//            
            System.out.println(temp);
            System.out.println(i);
        }
        
//    // Get end time
    long endTime = System.currentTimeMillis();
    
    //Calculate the running time
    long runningTime = endTime - startTime;

    	System.out.println("Running time: " + runningTime + " milliseconds");
        System.out.println("Best tour cost: " + bestTour.getTourDistance());
        System.out.println("Best tour order: " + bestTour.toString());
        writeOutputFile("TSP_107.txt", "output.txt", bestTour);
        writer.write("Total cost of travel:" + bestTour.getTourDistance() + "\t");
        writer.write("Runtime:" + runningTime);
        }
        writer.close();
    }
    
    private static void writeOutputFile(String inputFile, String outputFile, Tour tour) {
        List<String> outputLines = new ArrayList<>();
        try (Scanner scanner = new Scanner(new File(inputFile))) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (line.equals("EOF")) {
                    break;
                }
                outputLines.add(line);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        int[] order = new int[numCities];
        for (int i = 0; i < numCities; i++) {
            order[i] = tour.getCities().get(i).getId();
        }
        List<String> orderedLines = new ArrayList<>();
        for (int i = 0; i < numCities; i++) {
            for (String line : outputLines) {
                int id = Integer.parseInt(line.split(" ")[0]);
                if (id == order[i]) {
                    orderedLines.add(line);
                    break;
                }
            }
        }
        try {
            Files.write(Paths.get(outputFile), orderedLines);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Reads city data from a text file and create City objects to represent each city
     * 
     * @param filename the name of the file containing city data
     */

    private static void readInputFile(String filename) {
    	/**
    	 * An ArrayList to store the cities
    	 */
        cities = new ArrayList<>();
        try (Scanner scanner = new Scanner(new File(filename))) {
            while (scanner.hasNextLine()) {
            	
                String line = scanner.nextLine();
                String[] tokens = line.split(" ");
                
                if (line.equals("EOF")) {
                    break;
                }
                
                int id = Integer.parseInt(tokens[0]);
                int x = Integer.parseInt(tokens[1]);
                int y = Integer.parseInt(tokens[2]);
                City city = new City(id, x, y);
                cities.add(city);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        /**
         * The number of cities in the ArrayList
         */
        numCities = cities.size();
    }

//    /**
//     * Initialize a 2D array of distances between cities
//     * The (i, j)-th element represents the distance between the i-th and j-th cities
//     * Uses the distanceTo() method of the City class to calculate the distances
//     */
//    private static void initializeDistances() {
//    	/**
//    	 * A 2D array of distances between cities
//    	 * The (i, j)-th element represents the distance between the i-th and j-th cities
//    	 */
//        distances = new double[numCities][numCities];
//        for (int i = 0; i < numCities; i++) {
//            City city1 = cities.get(i);
//            for (int j = 0; j < numCities; j++) {
//                City city2 = cities.get(j);
//                double distance = city1.distanceTo(city2);
//                distances[i][j] = distance;
//            }
//        }
//    }

    /**
     * Determines whether or not to accept a new solution in a simulated annealing algorithm
     * Compares the new energy to the current energy and the temperature of the system
     * Uses an acceptance probability equation to make the decision
     * @param currentEnergy the current energy of the system
     * @param newEnergy the energy of the new solution
     * @param temperature the temperature of the system
     * @return true if the new solution should be accepted, false otherwise
     */
    private static boolean acceptNewSolution(double currentEnergy, double newEnergy, double temperature) {
        if (newEnergy < currentEnergy) {
            return true;
        }
        double acceptanceProbability = Math.exp((currentEnergy - newEnergy) / temperature);
        return Math.random() < acceptanceProbability;
    }
    
    /**
     * Represents a city in a traveling salesman problem, with an ID and x and y coordinates
     * Provides a method to calculate the distance between two cities
     */
    private static class City {
        private int id;
        private int x;
        private int y;
        
        /**
         * Construct a new City object with the specified ID and x and y coordinates
         * @param id the ID of the city
         * @param x the x coordinate of the city
         * @param y the y coordinate of the city
         */
        public City(int id, int x, int y) {
            this.id = id;
            this.x = x;
            this.y = y;
        }

        public int getId() {
            return id;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        /**
         * Calculate the distance between this city and another city
         * @param other the other city to calculate the distance to __
         * @return the distance between this city and the other city
         */
        public double distanceTo(City other) {
            int dx = x - other.getX();
            int dy = y - other.getY();
            return Math.sqrt(dx * dx + dy * dy);
        }
    }

    /**
     * 
     * Represents a tour of cities in a traveling salesman problem
     * Provide method to create new tours from existing ones, get the order of cities in the tour and display the tour as a string
     *
     */
    private static class Tour {
    	/**
    	 * List of cities in the tour
    	 */
        private List<City> cities;
        
        /**
         * Construct a new Tour object with the specified list of cities
         * @param cities the list of cities to include in the tour
         */
        public Tour(List<City> cities) {
            this.cities = new ArrayList<>(cities);
        }
        
        /**
         * Constructs a new Tour object with the same list of cities as the specifies Tour object
         * @param tour the Tour object to copy the list of cities
         */
        public Tour(Tour tour) {
        	this.cities = new ArrayList<>(tour.cities);
        }

        public List<City> getCities() {
            return cities;
        }
        
        /**
         * Returns  a string representation of the tour
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            for (City city : cities) {
                sb.append(city.getId()).append(", ");
            }
            sb.delete(sb.length() - 2, sb.length()); // remove trailing comma and space
            sb.append("]");
            return sb.toString();
        }

        /**
         * Calculate the total distance of tour
         * @param distances a 2D array representing the distances between cities
         * @return total distance of tour
         */
        public double getTourDistance() {
            double distance = 0;
            for (int i = 0; i < numCities - 1; i++) {
                City city1 = cities.get(i);
                City city2 = cities.get(i + 1);
                distance += city1.distanceTo(city2);
            }
            City lastCity = cities.get(numCities - 1);
            City firstCity = cities.get(0);
            distance += lastCity.distanceTo(firstCity);
            return distance;
        }


        /**
         * Swap the positions of two cities in the tour
         * @param i the index of first city to be swapped
         * @param j the index of second city to be swapped
         */
        public void swapCities(int i, int j) {
            if (i != j) {
                City temp = cities.get(i);
                cities.set(i, cities.get(j));
                cities.set(j, temp);
            }
        }
    }
}
