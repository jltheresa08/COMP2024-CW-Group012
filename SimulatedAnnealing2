import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class SimulatedAnnealingTSP {

    static class Cities {
        int node;
        double x, y;

        public Cities(int node, double x, double y) {
            this.node = node;
            this.x = x;
            this.y = y;
        }
    }

    static class Tour {
        List<Integer> path;
        double cost;

        public Tour(List<Integer> path, double cost) {
            this.path = path;
            this.cost = cost;
        }
    }

    static double distance(Cities node1, Cities node2) {
        double dx = node1.x - node2.x;
        double dy = node1.y - node2.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    static List<Cities> readNodesFromFile(String filename) throws Exception {
        List<Cities> nodes = new ArrayList<Cities>();
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        String line;
        while ((line = reader.readLine()) != null && !line.equals("EOF")) {
            String[] fields = line.split("\\s+");
            int id = Integer.parseInt(fields[0]);
            double x = Double.parseDouble(fields[1]);
            double y = Double.parseDouble(fields[2]);
            nodes.add(new Cities(id, x, y));
        }
        reader.close();
        return nodes;
    }

    static double tourCost(List<Cities> nodes, List<Integer> path) {
        double cost = 0.0;
        for (int i = 0; i < path.size() - 1; i++) {
            int node1 = path.get(i);
            int node2 = path.get(i + 1);
            cost += distance(nodes.get(node1), nodes.get(node2));
        }
        cost += distance(nodes.get(path.get(path.size() - 1)), nodes.get(0));
        return cost;
    }

    static Tour simulatedAnnealing(List<Cities> nodes, double temperature, double coolingRate, int iterations) {
        // Initialize the current solution with a random path
        List<Integer> currentPath = new ArrayList<Integer>();
        for (int i = 0; i < nodes.size(); i++) {
            currentPath.add(i);
        }
        Collections.shuffle(currentPath);
        Tour currentSolution = new Tour(currentPath, tourCost(nodes, currentPath));
        Tour bestSolution = currentSolution;

        // Iterate until temperature reaches 0
        for (int i = 0; i < iterations && temperature > 1e-6; i++) {
            // Generate a new solution by randomly swapping two cities
            List<Integer> newPath = new ArrayList<Integer>(currentPath);
            int index1 = (int) (Math.random() * nodes.size());
            int index2 = (int) (Math.random() * nodes.size());
            int temp = newPath.get(index1);
            newPath.set(index1, newPath.get(index2));
            newPath.set(index2, temp);
            Tour newSolution = new Tour(newPath, tourCost(nodes, newPath));

            // Determine whether to accept the new solution
            double delta = newSolution.cost - currentSolution.cost;
            if (delta < 0 || Math.exp(-delta / temperature) > Math.random()) {
                currentSolution = newSolution;
            }

            // Update the best solution if the current solution is better
            if (currentSolution.cost < bestSolution.cost) {
                bestSolution = currentSolution;
            }

            // Update the temperature
            temperature *= coolingRate;
        }

        return bestSolution;
    }

    public static void main(String[] args) {
    	String filename = "TSP_107.txt";
    	int numIterations = 10000;
    	double initialTemperature = 10000;
    	double coolingRate = 0.003;
    	
        // Read the cities from file
        List<Cities> cities = null;
        try {
            cities = readNodesFromFile(filename);
        } catch (Exception e) {
            System.out.println("Error reading file: " + e.getMessage());
            return;
        }

        // Solve the TSP using simulated annealing
        Tour bestTour = simulatedAnnealing(cities, initialTemperature, coolingRate, numIterations);

        // Output the results
        System.out.println("Best tour cost: " + bestTour.cost);
        System.out.print("Best tour path: ");
        for (int i = 0; i < bestTour.path.size(); i++) {
            System.out.print(bestTour.path.get(i));
            if (i < bestTour.path.size() - 1) {
                System.out.print(" -> ");
            }
        }
        System.out.println();
    } 
}
